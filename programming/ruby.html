<!DOCTYPE html>
<html>
	<head>
		<base href=".." />
		<script src="scripts/loadScripts.js"></script>
	</head>
	<body>
		<noscript>JavaScript must be enabled to view this website in all its beauty. Click the script button in the right side of your address bar to allow JavaScript. Fear not, this site does not use harmful scripts to steal your identity or take over your computer. JavaScript is used purely for formatting this site. You can still view the content below, but some elements may not be formatted correctly.</noscript>
		<div id="content-container">
			<a href="https://www.ruby-lang.org/en/"><img src="images/language-icons/ruby.png" id="language-icon" /></a>
			<h1 id="page-title">Ruby</h1>
			<div class="paragraph">
				<em>
					(This page in particular I have spent some time writing.
					I will be up-front and say I don't like Ruby, but the more I write about Ruby, the less I can find myself complaining about it.
					The more I understand Ruby the more I'll update the information here.)
				</em>
			</div>
			<div class="paragraph">
				<a href="https://www.ruby-lang.org/en/">Ruby</a> is an object-oriented (OO) scripting language.
				Ruby was designed to be intelligible to humans and not just to machines.
				Most languages use strict syntax so the computer will understand what its instructions are.
				Ruby, on the other hand, uses English syntax to aid in readability and has numerous techniques to do the same thing to aid in ease of writing.
			</div>
			<div class="paragraph">
				I am an advocate of removing unnecessary syntax: I don't like having a million ways to do something.
				Because of that, I am not a fan of Ruby.
				There is a lot to Ruby that I don't know and don't understand, but from what I know I don't particularly take to it.
				That being said, I am not saying to not learn Ruby: quite the opposite.
				Ruby is one of the languages everyone in programming should learn.
				It is used in web development (<a href="http://rubyonrails.org/">Ruby on Rails</a>) and is available on most major platforms.
				I tried it out of curiosity and don't like it, but that doesn't mean you won't like it either.
			</div>
			<div class="paragraph">
				<h2>Features of Ruby</h2>
				Before jumping into what I don't like about Ruby, I think it's only fair to write about some of the features the language offers.
				Primarily I will focus on what the language has that most languages don't have.
			</div>
			<div class="paragraph">
				<h3>Hashes, Classes, and Modulemobiles</h3>
				I love Lua, and as such, I am used to everything being a table.
				Ruby, however, takes a more Pythonic approach to various data types.
				Ruby has hashes, classes, and modules, which parallel Python's dicts, classes, and classes (again).
				Dictionaries in Python, hashes in Ruby, and tables in Lua are all similar: a set of key-value pairs.
				Lua does not have a concept of classes, but Ruby and Python do.
				The classes allow you to create innumerable instances of them and extend other classes.
				Ruby takes things a step further by adding modules, which are essentially static classes or interfaces that can be implemented by any class.
			</div>
			<div class="paragraph">
				<h3>Symbols</h3>
				Ruby provides a special data type called a <em>symbol</em>.
				In normal OO languages, objects are unique and multiple clones may not point to the same location.
				For example, I ran the following two blocks of code separately.
				In the first box you see the two object ids for the strings differ.
				Even though the two strings are the same arrangement of characters and equate to each other, they refer to different objects.
				Symbols, written like <code>:symbol_name</code>, evaluate to themselves.
				All symbols of the same name across a Ruby program have the exact same object id.
				As such, they are convenient as keys in hashes and method names because of their uniqueness and immutability.
			</div>
<pre>
a = "This is a string"
b = "This is a string"
puts a.object_id                  #=&gt; 74149330
puts b.object_id                  #=&gt; 74149320
puts a == b                       #=&gt; true
puts a.object_id == b.object_id   #=&gt; false
</pre>
<pre>
a = :symbol_name
b = :symbol_name
puts a.object_id                  #=&gt; 146968
puts b.object_id                  #=&gt; 146968
puts a == b                       #=&gt; true
puts a.object_id == b.object_id   #=&gt; true
</pre>
			<div class="paragraph">
				<h3>Sigils</h3>
				Ruby also has what are called sigils.
				In some languages, like Perl, sigils appear next to variable names to indicate the type of the value (in Perl <code>$</code> indicates the value is a scaler, <code>@</code> indicates it's an array, etc).
				In Ruby, sigils have two types.
				The first type of sigil prefixes the variable name and sets the scope of a variable.
				There are five types of variables in Ruby, each defined by how the variable name starts.
				On the left are how a variable can start and on the right are what type of variable it will be.
				<ul>
					<table>
						<tr>
							<td><li><code>a-z</code> or <code>_</code></li></td>
							<td>local variable</td>
						</tr>
						<tr>
							<td><li><code>A-Z</code></li></td>
							<td>constant</td>
						</tr>
						<tr>
							<td><li><code>$</code></li></td>
							<td>global variable</td>
						</tr>
						<tr>
							<td><li><code>@@</code></li></td>
							<td>class variable</td>
						</tr>
						<tr>
							<td><li><code>@</code></li></td>
							<td>instance variable</td>
						</tr>
					</table>
				</ul>
				Anything else at the front of a variable name would not be allowed as a variable name.
			</div>
			<div class="paragraph">
				The second type of sigil suffixes a method name to indicate the return value of a method.
				One sigil that I wished was in Lua is the <em>query sigil</em> <code>?</code>.
				The query comes at the end of a method name to indicate it's a predicate (returns a boolean).
				This makes the code look a bit more like English.
				For example: <code>"some string".includes? "t"</code> reads like "does 'some string' include 't'?", to which the answer is 'yes'.
				Another sigil is the <em>bang sigil</em> <code>!</code>.
				The bang follows a method name to indicate the method is a "dangerous" method, one that affects the object in question and does not merely return a new object.
				Take the following:
			</div>
<pre>
# no bang

a = [1, 4, 2, 5, 3]
b = a.sort

puts a.inspect    #=&gt; [1, 4, 2, 5, 3]
puts b.inspect    #=&gt; [1, 2, 3, 4, 5]
</pre>
<pre>
# with a bang

a = [1, 4, 2, 5, 3]
b = a.sort!

puts a.inspect    #=&gt; [1, 2, 3, 4, 5]
puts b.inspect    #=&gt; [1, 2, 3, 4, 5]
</pre>
			<div class="paragraph">
				<h4>A Quick Note About Constants</h4>
				Since I previously mentioned constants I would like to append some extra information about them.
				Constants are called "constants" in various languages but their implementations differ.
				In C, a constant variable is completely immutable: you cannot change where it points or any of the values bundled inside it.
				To change the values inside a constant in C you would need to declare the variable as a constant pointer, which doesn't let you change where it points, but allows you to change the values inside.
				In Java, constant variables (those declared <em>final</em>) act like constant pointers from C.
				Ruby constants act like constant pointers, but Ruby doesn't enforce constant-ness.
				You can actually change the references of constant variables; Ruby will warn you when you attempt to change a constant value, but will let you do it anyway.
				Observe:
			</div>
<pre>
# Input.rb

# Set original value
A_CONST = "Hello"
puts A_CONST       #=&gt; Hello

# You can change the values inside the object
A_CONST[0] = "J"
puts A_CONST       #=&gt; Jello

# You shouldn't change the value of the variable
A_CONST = "Bob"
puts A_CONST       #=&gt; Input.rb:10: warning: already initialized constant A_CONST
                   #=&gt; Bob
</pre>
			<div class="paragraph">
				<h3>Blocks, Procs, and Lambdamobiles</h3>
				There are lambdas, procs, and blocks, and each has its own differences.
				All of these are Ruby's odd way of doing closures and passing functions around.
			</div>
			<div class="paragraph">
				<h4>Blocks</h4>
				Blocks are nameless pieces of code that are implicitely "passed" to certain functions.
				You define a block after a method call and the method may yield to the block, sometimes passing values in.
				This sort of functionality is very convenient as it gives module and API writers the ability to generalize their code and gives module and API users the ability to define what's going on.
				Blocks are rather limited, however.
				For one, you can provide no more than one block to a method call.
				Blocks are also not objects and cannot be stored to a variable, but if you want to store them to variables, you can: that sounds contradictory, but read on.
			</div>
			<div class="paragraph">
				<h4>Procs</h4>
				Procs are objects with a customizable method that allows them to be explicitely or implicitely "passed" to certain functions.
				They can be defined and set in two ways.
				First, a proc can be set to a variable by using <code>Proc.new</code> and providing a block, like <code>square = Proc.new { |n| n ** 2 }</code> would create a Proc that, when called, returns the square of the passed number.
				Second, they can be created implicitely by using blocks.
				In a method, blocks can be either yielded to, or converted to a proc by preceding one of the parameters with <code>&amp;</code>.
				The following pieces of code do the exact same thing.
			</div>
<pre>
# Using a block

class Array
  def apply!
    self.each_with_index do |n, i|
      self[i] = yield(n)
    end
  end
end

result = [1,2,3,4].apply! do |n|
  n ** 2
end

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
<pre>
# Converting block to proc

class Array
  def apply!(&amp;code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

result = [1,2,3,4].apply! do |n|
  n ** 2
end

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
<pre>
# Passing a proc

class Array
  def apply!(code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

result = [1,2,3,4].apply!(
  Proc.new{ |n| n ** 2 }
)

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
			<div class="paragraph">
				Procs have one more added benefit.
				They act as if their code is injected directly into the code of its calling method, so any returns, breaks, exception raises, and other control flow keywords affect the calling method.
				For example, a proc with an explicit return called inside a method will break out and return from the method without executing any following code in the method.
			</div>
			<div class="paragraph">
				<h4>Lambdas</h4>
				Lambdas are procs.
				Technically speaking, <code>lambda</code> is a method in Ruby that converts a block into a special type of proc, so lambdas are not a different class (<code>puts (lambda {}).class  #=&gt; Proc</code>) but we still refer to these special procs as <em>lambdas</em>.
				Lambdas differ from procs in only two respects.
				First, lambdas check the number of arguments passed to them and will error when the number received and number expected differ.
				Procs do not check and will assign <code>nil</code> to unspecified arguments and will ignore extra passed arguments.
				Second, lambdas called within a method will not affect the control flow of the method: an explicit return in a lambda called inside a method will not break out, whereas a proc would.
				These differences are because lambdas act like regular methods but wrapped in an object.
			</div>
			<div class="paragraph">
				<h4>Method Objects</h4>
				In addition to blocks, procs, and lambdas, Ruby has the added capability of passing methods around using symbols.
				In Ruby, all methods are called automatically, regardless of the presence of parens: both <code>array.inspect</code> and <code>array.inspect()</code> are valid method calls.
				As such, one does not simply assign a method directly to a variable like they could in Lua or Python.
				Instead, there is the built-in Ruby method <code>method</code> which takes a symbol (the name of the method in question) and returns a Method object.
				Method objects behave like regular methods, but wrapped in an object (same as lambdas): you call them with <code>.call</code>, they complain about argument mismatch, and they don't break out of their calling methods.
				You can even convert methods into blocks by prefixing the reference with an <code>&amp;</code> and placing them after a method call.
				Using the code from above, the following are also legal, thus providing us with at least six ways to square every element in an array.
			</div>
<pre>
# Passing a Method object

class Array
  def apply!(code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

def square(n)
  n ** 2
end

result = [1,2,3,4].apply!(method(:square))

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
<pre>
# Converting Method object to block

class Array
  def apply!
    self.each_with_index do |n, i|
      self[i] = yield(n)
    end
  end
end

def square(n)
  n ** 2
end

result = [1,2,3,4].apply! &amp;method(:square)

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
<pre>
# Converting Method object to block to proc

class Array
  def apply!(&amp;code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

def square(n)
  n ** 2
end

result = [1,2,3,4].apply! &amp;method(:square)

puts result.inspect  #=&gt; [1, 4, 9, 16]
</pre>
			<div class="paragraph">
				<h2>Why Ruby Isn't my Cup of Tea</h2>
				If Python and Ruby were real humans, they would be bitter rivals: Python prides itself on being concise and having one way to do something; Ruby prides itself on being as redundant as it can possibly be.
				Like I said, I don't like having a million ways to do something; I like things to be a bit less chaotic.
				It seems like Matz (creator of Ruby) said to himself "I wonder if this should be put in" and never said no: he was so preoccupied with whether or not he could that he didn't stop to think if he should.
				There are many instances in Ruby where there are various means to achieve the same thing.
				It isn't that big of an issue to have multiple ways to do something: in fact, having all these different options gives a better chance that it is possible to do whatevery you want to do.
				The issue for me is that all these redundancies lead to inconsistent code, which in turn affects comprehensibility.
			</div>
			<div class="paragraph">
				<h3>Matz's Third Law:</h3>
				<h4 style="margin-left:3em;">for every control-flow, there is an equal and opposite re-control-flow</h4>
				Just like any language Ruby has the <code>if ...</code> statement, but there is its complement <code>unless ...</code> which the same as <code>if not ...</code>.
				There is <code>while ...</code> and also <code>until ...</code>, identical to <code>while not ...</code>.
				For these, I can sort of understand why there are the complements.
				Ruby is designed for readability, and sometimes it is easier for some to say "unless you're tired, run" instead of "if you're not tired, run".
				I'd still opt for the latter.
			</div>
			<div class="paragraph">
				<h3>Optional and Assumed Syntax</h3>
				There aren't many languages with completely optional syntax.
				In Lua, you have the option of following your statements with a semicolon, which is used for disambiguity.
				It's required in some instances when the compiler has the possibility of getting confused with what you've written.
				In JavaScript, the semicolon at the end of statements is also somewhat optional.
				When parsing through the script, if JS doesn't find a semicolon where it expects one, it will imagine one is there and continue through.
				Include your semicolons anyway.
			</div>
			<div class="paragraph">
				Ruby is the only language that I can think of where certain keywords are completely optional.
				For one, every method is automatically called with all following comma separated values (up to a newline) passed as arguments, so the parentheses are not required.
				The parentheses are also not required for method definitions.
				In fact, parentheses are completely optional: they are needed only for clarification for the interpreter, like for specifying the order of arithmetic operations.
				The keywords <code>do</code> and <code>then</code> are optional after <code>while</code>, <code>until</code>, <code>if</code>, and <code>unless</code>.
				The <code>return</code> keyword is also optional.
				Ruby automatically returns the last statement it evaluates, so a legal function is <code>def square(n) n ** 2 end</code>.
				The only exception to <code>return</code> being optional is in a proc, where an explicit return jumps out of the calling method.
				That instance, however, is not really an exception since a proc call acts as if the code was written directly into the method.
			</div>
			<div class="paragraph">
				<h3>Too Many Loops</h3>
				Just a <code>while</code> or infinite loop you can break out of is enough.
				Most languages offer other loops (like <code>for</code> and <code>repeat ... until</code>) as shorthand code, which is convenient; but Ruby must have more.
				<ul>
					<li><code>(array/hash).each</code>, <code>(array).each[_with_index|_index]</code>, and <code>(hash).each[_pair|_key|_value]</code> for iterating over every element of an enumerable</li>
					<li><code>(int).times</code> or <code>(int).upto(int)</code> for iterating a definitive number of times</li>
					<li><code>for</code> for over every element of an enumerable or iterating a definitive number of times</li>
					<li><code>loop</code> for iterating forever</li>
					<li><code>while</code> for iterating as determined now</li>
					<li><code>until</code> for iterating as determined later</li>
				</ul>
			</div>
		</div>
	</body>
</html>
